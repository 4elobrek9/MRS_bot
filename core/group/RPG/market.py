import logging
from typing import Dict, List, Tuple
import json
import time

from aiogram import Router, types, F, Bot
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.types import InlineKeyboardButton
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.context import FSMContext

# Import from core
from core.group.stat.shop_config import ShopConfig

# Import from our own package using relative imports
from .MAINrpg import rpg_router
from .item import ItemSystem
from .rpg_utils import ensure_db_initialized
from .inventory import get_user_lumcoins, get_user_inventory_db, remove_item_from_inventory
from .market_db import (
    get_market_listings, 
    add_market_listing, 
    remove_market_listing,
    get_seller_listings
)

# Local logger
logger = logging.getLogger(__name__)

class MarketStates(StatesGroup):
    waiting_for_price = State()
@rpg_router.message(F.text.lower() == "—Ä—ã–Ω–æ–∫")
async def show_market(message: types.Message, profile_manager):
    try:
        user_id = message.from_user.id
        lumcoins = await get_user_lumcoins(profile_manager, user_id)
        
        builder = InlineKeyboardBuilder()
        text = f"üè™ **–†—ã–Ω–æ–∫** | üí∞ –ë–∞–ª–∞–Ω—Å: {lumcoins} LUM\n\n"
        
        market_items = await get_market_listings()
        
        if market_items:
            text += "üõí **–¢–æ–≤–∞—Ä—ã:**\n\n"
            for item in market_items[:5]:
                item_info = json.loads(item['item_data'])
                item_name = item_info.get('name', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ø—Ä–µ–¥–º–µ—Ç')
                seller_name = f"üë§ {item['seller_id']}"
                
                text += f"üì¶ {item_name}\n"
                text += f"üí∞ –¶–µ–Ω–∞: {item['price']} LUM\n"
                text += f"{seller_name}\n\n"
                
                builder.row(InlineKeyboardButton(
                    text=f"üõí {item_name} - {item['price']} LUM",
                    callback_data=f"market_buy:{item['id']}"
                ))
        else:
            text += "üì≠ –ù–∞ —Ä—ã–Ω–∫–µ –ø–æ–∫–∞ –Ω–µ—Ç —Ç–æ–≤–∞—Ä–æ–≤.\n"
        
        builder.row(InlineKeyboardButton(
            text="üì§ –í—ã—Å—Ç–∞–≤–∏—Ç—å —Ç–æ–≤–∞—Ä", 
            callback_data="market_sell_menu"
        ))
        
        builder.row(InlineKeyboardButton(
            text="üîÑ –û–±–Ω–æ–≤–∏—Ç—å", 
            callback_data="market_refresh"
        ))
        
        builder.row(InlineKeyboardButton(
            text="üì¶ –ú–æ–∏ —Ç–æ–≤–∞—Ä—ã", 
            callback_data="market_my_listings"
        ))
        
        await message.answer(text, reply_markup=builder.as_markup())
        
    except Exception as e:
        logger.error(f"‚ùå Error in show_market: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Ä—ã–Ω–∫–∞")

@rpg_router.callback_query(F.data == "market_sell_menu")
async def handle_market_sell_menu(callback: types.CallbackQuery, profile_manager):
    try:
        user_id = callback.from_user.id
        user_inventory = await get_user_inventory_db(user_id)
        
        sellable_items = [item for item in user_inventory if item.get('type') != 'background' and item.get('quantity', 0) > 0]
        
        if not sellable_items:
            await callback.answer("‚ùå –£ –≤–∞—Å –Ω–µ—Ç –ø—Ä–µ–¥–º–µ—Ç–æ–≤ –¥–ª—è –ø—Ä–æ–¥–∞–∂–∏")
            return
        
        builder = InlineKeyboardBuilder()
        text = "üè™ **–ü—Ä–æ–¥–∞–∂–∞ –Ω–∞ —Ä—ã–Ω–∫–µ**\n\n"
        text += "–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–µ–¥–º–µ—Ç –¥–ª—è –ø—Ä–æ–¥–∞–∂–∏:\n\n"
        
        for item in sellable_items[:5]:
            item_key = item.get('item_key', 'unknown')
            item_name = item.get('name', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ø—Ä–µ–¥–º–µ—Ç')
            quantity = item.get('quantity', 1)
            
            builder.row(InlineKeyboardButton(
                text=f"{item_name} √ó{quantity}",
                callback_data=f"market_select:{item_key}"
            ))
        
        builder.row(InlineKeyboardButton(
            text="‚Ü©Ô∏è –ù–∞–∑–∞–¥", 
            callback_data="market_back"
        ))
        
        await callback.message.edit_text(text, reply_markup=builder.as_markup())
        
    except Exception as e:
        logger.error(f"‚ùå Error in show_market_sell_menu: {e}")
        await callback.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –º–µ–Ω—é")

@rpg_router.callback_query(F.data.startswith("market_select:"))
async def handle_market_select(callback: types.CallbackQuery, profile_manager, state: FSMContext):
    try:
        user_id = callback.from_user.id
        item_key = callback.data.split(":")[1]
        
        user_inventory = await get_user_inventory_db(user_id)
        item_data = None
        for item in user_inventory:
            if item.get('item_key') == item_key:
                item_data = item
                break
        
        if not item_data:
            await callback.answer("‚ùå –ü—Ä–µ–¥–º–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω")
            return
        
        item_info = ItemSystem.SHOP_ITEMS.get(item_key) or ItemSystem.CRAFTED_ITEMS.get(item_key)
        item_name = item_info['name'] if item_info else item_data.get('name', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ø—Ä–µ–¥–º–µ—Ç')
        
        base_price = ItemSystem.get_item_sell_price(item_key) * 3
        min_price = int(base_price * 0.5)
        max_price = int(base_price * 3)
        
        await state.set_state(MarketStates.waiting_for_price)
        await state.update_data(
            market_item_key=item_key,
            market_item_name=item_name,
            market_base_price=base_price,
            market_min_price=min_price,
            market_max_price=max_price
        )
        
        builder = InlineKeyboardBuilder()
        builder.row(InlineKeyboardButton(
            text="‚ùå –û—Ç–º–µ–Ω–∞",
            callback_data="market_cancel"
        ))
        
        await callback.message.edit_text(
            f"üè™ **–ü—Ä–æ–¥–∞–∂–∞: {item_name}**\n\n"
            f"üí∞ –ë–∞–∑–æ–≤–∞—è —Ü–µ–Ω–∞: {base_price} LUM\n\n"
            f"üíé **–í–≤–µ–¥–∏—Ç–µ –≤–∞—à—É —Ü–µ–Ω—É:**\n"
            f"–ù–∞–ø–∏—à–∏—Ç–µ –≤ —á–∞—Ç: —Ü–µ–Ω–∞ [—á–∏—Å–ª–æ]\n"
            f"–ù–∞–ø—Ä–∏–º–µ—Ä: —Ü–µ–Ω–∞ {min_price + 10}\n\n"
            f"üìä –î–∏–∞–ø–∞–∑–æ–Ω —Ü–µ–Ω:\n"
            f"‚Ä¢ –ú–∏–Ω–∏–º—É–º: {min_price} LUM (50%)\n"
            f"‚Ä¢ –ú–∞–∫—Å–∏–º—É–º: {max_price} LUM (300%)",
            reply_markup=builder.as_markup()
        )
        
    except Exception as e:
        logger.error(f"‚ùå Error in handle_market_select: {e}")
        await callback.answer("‚ùå –û—à–∏–±–∫–∞")

@rpg_router.message(MarketStates.waiting_for_price)
async def handle_market_price_input(message: types.Message, state: FSMContext, profile_manager):
    try:
        user_id = message.from_user.id
        data = await state.get_data()
        item_key = data.get('market_item_key')
        item_name = data.get('market_item_name')
        base_price = data.get('market_base_price')
        min_price = data.get('market_min_price')
        max_price = data.get('market_max_price')
        
        if not item_key:
            await message.answer("‚ùå –û—à–∏–±–∫–∞: –ø—Ä–µ–¥–º–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω")
            await state.clear()
            return
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤–≤–µ–¥–µ–Ω–æ —á–∏—Å–ª–æ
        try:
            if message.text.lower().startswith('—Ü–µ–Ω–∞ '):
                price = int(message.text.split()[1])
            else:
                price = int(message.text.strip())
        except (ValueError, AttributeError, IndexError):
            await message.answer("‚ùå –¶–µ–Ω–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —á–∏—Å–ª–æ–º. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–æ—Ä–º–∞—Ç: —Ü–µ–Ω–∞ [—á–∏—Å–ª–æ]")
            return
        
        if price < min_price:
            await message.answer(f"‚ùå –¶–µ–Ω–∞ —Å–ª–∏—à–∫–æ–º –Ω–∏–∑–∫–∞—è. –ú–∏–Ω–∏–º—É–º: {min_price} LUM")
            return
        
        if price > max_price:
            await message.answer(f"‚ùå –¶–µ–Ω–∞ —Å–ª–∏—à–∫–æ–º –≤—ã—Å–æ–∫–∞—è. –ú–∞–∫—Å–∏–º—É–º: {max_price} LUM")
            return
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø—Ä–µ–¥–º–µ—Ç –µ—â–µ –µ—Å—Ç—å —É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user_inventory = await get_user_inventory_db(user_id)
        item_found = False
        for item in user_inventory:
            if item.get('item_key') == item_key:
                item_found = True
                break
        
        if not item_found:
            await message.answer("‚ùå –ü—Ä–µ–¥–º–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –≤–∞—à–µ–º –∏–Ω–≤–µ–Ω—Ç–∞—Ä–µ")
            await state.clear()
            return
        
        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ –ø—Ä–µ–¥–º–µ—Ç–µ
        item_data = ItemSystem.SHOP_ITEMS.get(item_key) or ItemSystem.CRAFTED_ITEMS.get(item_key)
        if not item_data:
            await message.answer("‚ùå –û—à–∏–±–∫–∞: –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø—Ä–µ–¥–º–µ—Ç–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
            await state.clear()
            return

        # –£–¥–∞–ª—è–µ–º –ø—Ä–µ–¥–º–µ—Ç –∏–∑ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è
        success = await remove_item_from_inventory(user_id, item_key, 1)
        if not success:
            await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –ø—Ä–µ–¥–º–µ—Ç–∞ –∏–∑ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è")
            await state.clear()
            return
        
        # –î–æ–±–∞–≤–ª—è–µ–º –≤ market
        success, result_message = await add_market_listing(user_id, item_key, item_data, price)
        
        if success:
            await remove_item_from_inventory(user_id, item_key, 1)
            await message.answer(f"‚úÖ {item_name} –≤—ã—Å—Ç–∞–≤–ª–µ–Ω –Ω–∞ —Ä—ã–Ω–æ–∫ –∑–∞ {price} LUM!")
        else:
            await message.answer(result_message)
        
        await state.clear()
        
    except Exception as e:
        logger.error(f"‚ùå Error in handle_market_price_input: {e}")
        await message.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞")
        await state.clear()

@rpg_router.callback_query(F.data == "market_cancel")
async def handle_market_cancel(callback: types.CallbackQuery, state: FSMContext):
    await state.clear()
    await callback.message.edit_text("‚ùå –í—ã—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–µ–¥–º–µ—Ç–∞ –æ—Ç–º–µ–Ω–µ–Ω–æ")

@rpg_router.callback_query(F.data == "market_refresh")
async def handle_market_refresh(callback: types.CallbackQuery, profile_manager):
    await show_market(callback.message, profile_manager)

@rpg_router.callback_query(F.data == "market_back")
async def handle_market_back(callback: types.CallbackQuery, profile_manager):
    await show_market(callback.message, profile_manager)
    
@rpg_router.callback_query(F.data == "market_my_listings")
async def handle_my_listings(callback: types.CallbackQuery):
    try:
        user_id = callback.from_user.id
        listings = await get_seller_listings(user_id)
        
        if not listings:
            await callback.answer("–£ –≤–∞—Å –Ω–µ—Ç –≤—ã—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã—Ö –ø—Ä–µ–¥–º–µ—Ç–æ–≤ –Ω–∞ —Ä—ã–Ω–∫–µ")
            return
        
        builder = InlineKeyboardBuilder()
        text = "üì¶ **–í–∞—à–∏ –ø—Ä–µ–¥–º–µ—Ç—ã –Ω–∞ —Ä—ã–Ω–∫–µ:**\n\n"
        
        for listing in listings:
            item_info = listing['item_data']
            item_name = item_info.get('name', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ø—Ä–µ–¥–º–µ—Ç')
            
            text += f"‚Ä¢ {item_name}\n"
            text += f"üí∞ –¶–µ–Ω–∞: {listing['price']} LUM\n\n"
            
            builder.row(InlineKeyboardButton(
                text=f"‚ùå –£–±—Ä–∞—Ç—å {item_name}",
                callback_data=f"market_remove:{listing['id']}"
            ))
        
        builder.row(InlineKeyboardButton(
            text="‚Ü©Ô∏è –ù–∞–∑–∞–¥",
            callback_data="market_back"
        ))
        
        await callback.message.edit_text(text, reply_markup=builder.as_markup())
        
    except Exception as e:
        logger.error(f"‚ùå Error in handle_my_listings: {e}")
        await callback.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞")
        
@rpg_router.callback_query(F.data.startswith("market_remove:"))
async def handle_remove_listing(callback: types.CallbackQuery):
    try:
        user_id = callback.from_user.id
        listing_id = int(callback.data.split(":")[1])
        
        success, result_message = await remove_market_listing(listing_id, user_id)
        await callback.answer(result_message)
        
        if success:
            await handle_my_listings(callback)
        
    except Exception as e:
        logger.error(f"‚ùå Error in handle_remove_listing: {e}")
        await callback.answer("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞")

@rpg_router.message(F.text.lower() == "–º–∞–≥–∞–∑–∏–Ω")
async def show_shop_main(message: types.Message, profile_manager):
    try:
        user_id = message.from_user.id
        lumcoins = await get_user_lumcoins(profile_manager, user_id)
        
        builder = InlineKeyboardBuilder()
        
        builder.row(InlineKeyboardButton(
            text="üñºÔ∏è –ú–∞–≥–∞–∑–∏–Ω —Ñ–æ–Ω–æ–≤", 
            callback_data="shop_type:backgrounds"
        ))
        builder.row(InlineKeyboardButton(
            text="üì¶ –ú–∞–≥–∞–∑–∏–Ω –ø—Ä–µ–¥–º–µ—Ç–æ–≤", 
            callback_data="shop_type:items"
        ))
        
        text = (
            "üõí **–ú–∞–≥–∞–∑–∏–Ω** üõí\n\n"
            f"üí∞ –ë–∞–ª–∞–Ω—Å: {lumcoins} LUM\n\n"
            "üéØ –í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø:"
        )
        
        await message.answer(text, reply_markup=builder.as_markup())
    except Exception as e:
        logger.error(f"‚ùå Error in show_shop_main: {e}")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ –º–∞–≥–∞–∑–∏–Ω–∞")